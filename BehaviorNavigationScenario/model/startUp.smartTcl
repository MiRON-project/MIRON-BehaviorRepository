(format t "INIT DONE ~%")

(defun format-locations (s obj colonmod at-sign) (declare (ignore colonmod)) (declare (ignore at-sign)) (format s "~s" (get-value obj 'name)))

;;;;;;;;;;;;;;;;;;;;;

;; MENU
(defvar nmbr nil)
;
; SKILL - name / 3 input parameters maximum / 3 output parameters maximum
(defvar name_skill NIL)
(defvar skill_id NIL)
(defvar old_id NIL)
(defvar in_1_skill NIL)
(defvar in_2_skill NIL)
(defvar in_3_skill NIL)
(defvar out_1_skill NIL)
(defvar out_2_skill NIL)
(defvar out_3_skill NIL)
(defvar dist 0)
(defvar angle 0)
(defvar mapname NIL)
(defvar x 0)
(defvar y 0)
(defvar yaw 0)
(defvar locations-var NIL)
(defvar personname NIL)
(defvar query NIL)
(defvar radius 0)
(defvar xpos 0)
(defvar ypos 0)
(defvar obj_index NIL)

;(defvar id_skill -1) ; TODO: identifying the executed skill using its ID
;

(uiop:launch-program "xterm -e $ZMQSERVER_DIR/ZMQServer_broker")
(uiop:launch-program "xterm -e $ZMQSERVER_DIR/ZMQServer_client")
(uiop:launch-program "xterm -hold -e $MOOD2BE_DIR/Executor --tree=$SMART_PACKAGE_PATH/DataRepository/bundles/ModelRepository/Intralogistics/main_with_subtree.xml --skills=$SMART_PACKAGE_PATH/DataRepository/bundles/ModelRepository/ABR/SystemTiagoNavigation.skills.json")
(uiop:launch-program "$GROOT_DIR/Groot")

(defun menu()

(loop

  ;(format t " ---------------------------------------------------- ~%")
  ;(format t " ---------------------------------------------------- ~%")

  ; Loop - Continuous reading of skills
	(sleep 1)
  (let* ((obj_skill (tcl-kb-query :key '(is-a) :value '((is-a skill)) ) ))
		;(obj_skill 'NIL)
  		(setf name_skill (get-value obj_skill 'name)) ; read the name of the skill to execute
			(setf skill_id (get-value obj_skill 'id)) ; read the name of the skill to execute
  		(cond
				((eq old_id skill_id))
				((string-equal name_skill "NIL"))
				((string-equal name_skill "APPROACHLOCATION")
					(defparameter locations-var NIL)
					(setf locations-var (get-value obj_skill 'locationId))
					(cond
						((equal locations-var 1.0)
							(setf locations-var "SOFA"))
					)  
					(setf locations-var (intern locations-var))
					(execute `(nav1.tcb-approach-location ,locations-var))
					(tcl-kb-update :key '(is-a) :value `((is-a skill_result)(name APPROACHLOCATION)(id ,skill_id)(RESULT SUCCESS)) )  ;TODO: add id_skill
  			)
				((string-equal name_skill "MOVEROBOTERPOSITION")
					(setf xpos (get-value obj_skill 'x)) 
					(setf ypos (get-value obj_skill 'y)) ; y is actually z for webots
					(setf radius (get-value obj_skill 'approachRadius))
					(execute `(nav1.tcb-move-robot 'plain ,xpos ,ypos ,radius))
				;(abort-tcb *CURRENT-INSTANCE*)  
				(tcl-kb-update :key '(is-a) :value `((is-a skill_result)(name MOVEROBOTERPOSITION)(id ,skill_id)(RESULT SUCCESS)) )
					)
				((string-equal name_skill "MOVEROBOTERBACKWARDSLOCATION")
					(setf locations-var "HOME")
					(cond
					((equal in_1_skill 1.0)
						(setf locations-var "HOME"))
					((equal in_1_skill 2.0)
						(setf locations-var "SOFA"))
					((equal in_1_skill 3.0)
						(setf locations-var "TABLE"))
					((equal in_1_skill 4.0)
						(setf locations-var "BENCH"))
					)
							(setf locations-var (intern locations-var))
					(execute `(nav1.tcb-move-robot 'backward ,locations-var))
					(tcl-kb-update :key '(is-a) :value `((is-a skill_result)(name MOVEROBOTERBACKWARDSLOCATION)(id ,skill_id)(RESULT SUCCESS)) )
					)
				((string-equal name_skill "MOVEROBOTERBACKWARDSRELATIVE")
					(setf dist (round in_1_skill))
					(execute `(nav1.tcb-move-robot 'backward-abs ,dist))
				(tcl-kb-update :key '(is-a) :value `((is-a skill_result)(name MOVEROBOTERBACKWARDSRELATIVE)(id ,skill_id)(RESULT SUCCESS)) )
					)
				((string-equal name_skill "MOVEROBOTERORIENTATEROBOTABS")
					(setf angle (round in_1_skill))		; TODO: round? is not a good solution for angles
					(execute `(nav1.tcb-move-robot 'orientate-angle-absolute ,angle))
					(tcl-kb-update :key '(is-a) :value `((is-a skill_result)(name MOVEROBOTERORIENTATEROBOTABS)(id ,skill_id)(RESULT SUCCESS)) )
					)  
				((string-equal name_skill "MOVEROBOTERORIENTATEROBOTREL")
					(setf angle (round in_1_skill))		; TODO: round? is not a good solution for angles
					(execute `(nav1.tcb-move-robot 'orientate-angle-relative ,angle))
					(tcl-kb-update :key '(is-a) :value `((is-a skill_result)(name MOVEROBOTERORIENTATEROBOTREL)(id ,skill_id)(RESULT SUCCESS)) )
					)
				((string-equal name_skill "STARTJOYSTICKNAVIGATION")		
					(execute '(nav1.tcb-joystick-navigation))
				(tcl-kb-update :key '(is-a) :value `((is-a skill_result)(name STARTJOYSTICKNAVIGATION)(id ,skill_id)(RESULT SUCCESS)) )
					)
					((string-equal name_skill "STOPJOYSTICKNAVIGATION")		
					(execute '(nav1.tcb-stop-joystick-navigation))
				(tcl-kb-update :key '(is-a) :value `((is-a skill_result)(name STOPJOYSTICKNAVIGATION)(id ,skill_id)(RESULT SUCCESS)) )
					) 		
				((string-equal name_skill "STARTREACTIVENAVIGATION")		
					(execute '(nav1.tcb-reactive-navigation))
				(tcl-kb-update :key '(is-a) :value `((is-a skill_result)(name STARTREACTIVENAVIGATION)(id ,skill_id)(RESULT SUCCESS)) )
					)
					((string-equal name_skill "STOPREACTIVENAVIGATION")		
					(execute '(nav1.tcb-stop-reactive-navigation))
				(tcl-kb-update :key '(is-a) :value `((is-a skill_result)(name STOPREACTIVENAVIGATION)(id ,skill_id)(RESULT SUCCESS)) )
					)
					((string-equal name_skill "APPROACHWALL")		
					(execute '(nav1.tcb-approach-wall))
				(tcl-kb-update :key '(is-a) :value `((is-a skill_result)(name APPROACHWALL)(id ,skill_id)(RESULT SUCCESS)) )
					)
					((string-equal name_skill "LOADNAVIGATIONMAP")
					(setf mapname (string-downcase (get-value obj_skill 'mapname)))
					(execute `(nav1.tcb-load-navigation-map ,mapname))
					(tcl-kb-update :key '(is-a) :value `((is-a skill_result)(name LOADNAVIGATIONMAP)(id ,skill_id)(RESULT SUCCESS)) )
					) 
				((string-equal name_skill "INITNAVIGATION")		
					(execute '(nav1.tcb-init-navigation))
					(tcl-kb-update :key '(is-a) :value `((is-a skill_result)(name INITNAVIGATION)(id ,skill_id)(RESULT SUCCESS)) )
					)   			
				((string-equal name_skill "ACTIVATELOCALIZATION")		
					(execute '(localizationModInst.tcb-activate-localization))
					(tcl-kb-update :key '(is-a) :value `((is-a skill_result)(name ACTIVATELOCALIZATION)(id ,skill_id)(RESULT SUCCESS)) )
					)  			  			
				((string-equal name_skill "DEACTIVATELOCALIZATION")		
					(execute '(localizationModInst.tcb-deactivate-localization))
				(tcl-kb-update :key '(is-a) :value `((is-a skill_result)(name DEACTIVATELOCALIZATION)(id ,skill_id)(RESULT SUCCESS)) )
					)
				((string-equal name_skill "LOADMAP")
					(setf mapname (string-downcase (get-value obj_skill 'mapname)))
					(execute `(localizationModInst.tcb-load-localization-map ,mapname))
					(tcl-kb-update :key '(is-a) :value `((is-a skill_result)(name LOADMAP)(id ,skill_id)(RESULT SUCCESS)) )
					)
				((string-equal name_skill "SETROBOTPOSE")
					(setf x (round in_1_skill))
					(setf y (round in_2_skill))
					(setf yaw (round in_3_skill))	; TODO: round? is not a good solution for angles	
					(execute `(localizationModInst.tcb-set-robot-pose ,x ,y ,yaw))
				(tcl-kb-update :key '(is-a) :value `((is-a skill_result)(name SETROBOTPOSE)(id ,skill_id)(RESULT SUCCESS)) )
					)
				((string-equal name_skill "TRIGGERGLOBALLOCALIZATION")		
					(execute '(localizationModInst.tcb-trigger-global-localization))
				(tcl-kb-update :key '(is-a) :value `((is-a skill_result)(name TRIGGERGLOBALLOCALIZATION)(id ,skill_id)(RESULT SUCCESS)) )
					)
				((string-equal name_skill "GETBASEPOSE")
					(execute '(base.getBasePose => ?x ?y ?yaw)) 
					(let	(
							(output_1 (cdr (assoc '?x (tcb-env-vars *CURRENT-INSTANCE*))))
							(output_2 (cdr (assoc '?y (tcb-env-vars *CURRENT-INSTANCE*))))
							(output_3 (cdr (assoc '?yaw (tcb-env-vars *CURRENT-INSTANCE*))))
							)
						(tcl-kb-update :key '(is-a) :value `((is-a skill_result)(name GETBASEPOSE)(id ,skill_id)
							(OUT_1 ,output_1)
							(OUT_2 ,output_2)
							(OUT_3 ,output_3)
							(RESULT SUCCESS))
							)	
					)
				)
				((string-equal name_skill "GETBASECHARGING")
					(execute '(base.getBaseCharging => ?charging)) 
					(let	(
						(output_1 (cdr (assoc '?charging (tcb-env-vars *CURRENT-INSTANCE*))))
						)
						(tcl-kb-update :key '(is-a) :value `((is-a skill_result)(name GETBASECHARGING)(id ,skill_id)
							(OUT_1 ,output_1)(RESULT SUCCESS))
						)	
					)
				)
				((string-equal name_skill "PEOPLERECOGNITION")
					(execute '(detector.recognize-people))
					(tcl-kb-update :key '(is-a) :value `((is-a skill_result)(name PEOPLERECOGNITION)(id ,skill_id)(RESULT SUCCESS)))
				)
				((string-equal name_skill "GETPERSONPOSE")
					(setf personname (get-value obj_skill 'personname)) 
					(execute `(detector.getPersonPose ,personname => ?x ?y ?z ?result)) 
					(let	(
							(output_1 (cdr (assoc '?x (tcb-env-vars *CURRENT-INSTANCE*))))
							(output_2 (cdr (assoc '?y (tcb-env-vars *CURRENT-INSTANCE*))))
							(output_3 (cdr (assoc '?z (tcb-env-vars *CURRENT-INSTANCE*))))
							(result_ (cdr (assoc '?result (tcb-env-vars *CURRENT-INSTANCE*))))
							)
						(tcl-kb-update :key '(is-a) :value `((is-a skill_result)(name GETPERSONPOSE)(id ,skill_id)
							(OUT_1 ,output_1)
							(OUT_2 ,output_2)
							(OUT_3 ,output_3)
							(RESULT ,result_))
							)	
					)
				)
				((string-equal name_skill "OBJECTPLACEMENT")
					(setf query (get-value obj_skill 'query)) 
					(execute `(speech.objectplacement ,query => ?result))
					(let (
						(result_ (cdr (assoc '?result (tcb-env-vars *CURRENT-INSTANCE*))))
						)	
						(tcl-kb-update :key '(is-a) :value `((is-a skill_result)(name OBJECTPLACEMENT)(id ,skill_id)(RESULT ,result_)))
					)
				)
				((string-equal name_skill "OBJECTDROP")
						(setf obj_index (get-value obj_skill 'obj_index)) 
						(execute `(speech.objectdrop ,obj_index => ?result))
						(let (
							(result_ (cdr (assoc '?result (tcb-env-vars *CURRENT-INSTANCE*))))
							)	
							(tcl-kb-update :key '(is-a) :value `((is-a skill_result)(name OBJECTDROP)(id ,skill_id)(RESULT ,result_)))
						)
				)
				((string-equal name_skill "PATHPLANNER")
					(setf xpos (get-value obj_skill 'x)) 
					(setf ypos (get-value obj_skill 'y)) 
					(execute `(nav2.pathPlanner ,xpos ,ypos => ?number_of_waypoints ?waypoints)) 
					(let	(
							(output_1 (cdr (assoc '?number_of_waypoints (tcb-env-vars *CURRENT-INSTANCE*))))
							(output_2 (cdr (assoc '?waypoints (tcb-env-vars *CURRENT-INSTANCE*))))
							)
						(tcl-kb-update :key '(is-a) :value `((is-a skill_result)(name PATHPLANNER)(id ,skill_id)
							(OUT_1 ,output_1)
							(OUT_2 ,output_2))
							)	
					)
				)
			)
			(setf old_id skill_id)
  		
    
;  (setf nmbr (parse-integer (read-line nil)))
;  (format t "your choice: ~d ~%" nmbr)
  
;  (cond
;    ((equal nmbr 0)
;      (format t "bye bye ~%")
;      (quit)))
)))

(menu)